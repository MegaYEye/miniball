
########################################  [ 0, 15 ] -> 3 bytes ##########################################

unsigned uint16_t bitmap_a[] =
{
/*
 # lookup table: [0, 15] -> bit pattern (2x uint16_t, little endian)
 #
 # pattern:
 #
 # byte 0 (msb->lsb) : [    1,    0,    0,    1,    0,    0,    1,    0 ]
 # byte 1 (msb->lsb) : [    0,    1,    0,    0,    1, bit3,    0,    1 ]
 # byte 2 (msb->lsb) : [ bit2,    0,    1, bit1,    0,    1, bit0,    0 ]
 # byte 3 (msb->lsb) : [    1,    0,    0,    1,    0,    0,    1,    0 ]
 #

def waveform3(bit):
	return 0b100+0b010*int(bit != 0)

bitpatterns = [ sum( waveform3( (1<<bit)&n != 0 ) << (bit*3) for bit in range(8) ) for n in range(16) ]
for i, p in enumerate(bitpatterns):
	b0 = (p>>16)&0xff
	b1 = (p>> 8)&0xff
	b2 = (p>> 0)&0xff
	b3 = b2
	print (hex(b1<<8 | b0)+','+hex(b3<<8 | b2)+',' ,end='')
	if i%8 == 7:
		print()
 */
0x4992,0x2424,0x4992,0x2626,0x4992,0x3434,0x4992,0x3636,0x4992,0xa4a4,0x4992,0xa6a6,0x4992,0xb4b4,0x4992,0xb6b6,
0x4d92,0x2424,0x4d92,0x2626,0x4d92,0x3434,0x4d92,0x3636,0x4d92,0xa4a4,0x4d92,0xa6a6,0x4d92,0xb4b4,0x4d92,0xb6b6,
};

unsigned uint16_t bitmap_b[] =
{
/*
for i, p in enumerate(bitpatterns):
	b0 = (p>> 8)&0xff
	b1 = (p>> 0)&0xff
	print (hex(b1<<8 | b0)+',' ,end='')
	if i%16 == 15:
		print()

 */
0x2449,0x2649,0x3449,0x3649,0xa449,0xa649,0xb449,0xb649,0x244d,0x264d,0x344d,0x364d,0xa44d,0xa64d,0xb44d,0xb64d,
};


rRest
rBuf
rOut
rX
rCount
rP
rBitmapA
rBitmapB

/* // Pseudo-code
 *
 * extern uint16_t GAMMA[256], rBitmapA[16*2], rBitmapB[16]; // flash
 * extern uint8_t *rRest, *rBuff;
 * extern uint16_t *rOut;
 *
 * // every loop translates 2 bytes framebuffer input into 6 bytes gamma corrected waveform output
 *
 * rCount /= 2;
 * do {
 *
 * rX = *rRest++ + GAMMA[rBuff++];         // add 16 bit gamma corected value to temporal dithering remainder
 * rRest[-1] = (uint8_t)rX;                // save new remainder
 * rX = bswap16(rX);                       // byte swap value so that the low byte now contains the output color value
 *
 * rP = &rBitmapA[ (uint8_t)rX*2 ];        // calculate lookup location
 * rOut[0] = *rP++;                        // straight copy first two of three bytes of waveform
 * rOut[1] = *rP;                          // straight copy last byte of waveform + first byte of next waveform (identical for all values [0, 15])
 *
 * rX = *rRest++ + GAMMA[rBuff++];         // add 16 bit gamma corected value to temporal dithering remainder
 * rRest[-1] = (uint8_t)rX;                // save new remainder
 * rX = bswap16(rX);                       // byte swap value so that the low byte now contains the output color value
 *
 * rP = &rBitmapB[ (uint8_t)rX ];          // calculate lookup location
 * rOut[2] = *rP;                          // straight copy last byte of waveform + first byte of next waveform (identical for all values [0, 15])
 *
 * rOut = &rOut[3];
 *
 * } while (--rCount);
 */


rsa rCount, rCount

loop:
2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rX
3 add GAMMA(rP), rX
3 mov.b rX, -1(rRest)
1 swapb rX
1 mov.b rX, rP
1 add rP, rP
1 add rP, rP
1 add rBitmapA, rP
4 mov   @rP+, 0(rOut)                                 out > [ 1 0 0 1 0 0 1 0 0 1 0 0 1 A 0 1 ]
4 mov   @rP , 2(rOut)                                 out > [ B 0 1 D 0 1 D 0 1 0 0 1 0 0 1 0 ]

2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rX
3 add GAMMA(rP), rX
3 mov.b rX, -1(rRest)
1 swapb rX
1 mov.b rX, rP
1 add rP, rP
1 add rBitmapB, rP
4 mov   @rP, 4(rOut)                                  out > [ 0 1 0 0 1 A 0 1 B 0 1 D 0 1 D 0 ]

2 add #6, rOut
1 dec rCount
2 jnz loop

49/16.


########################################  1 byte -> 3 bytes ####################################################3

unsigned uint16_t bitmap_3[] =
{
/*
 # lookup table: byte -> bit pattern (2x uint16_t, little endian)
 #
 # pattern:
 #
 # byte 0 (msb->lsb) : [    1, bit7,    0,    1, bit6,    0,    1, bit5 ]
 # byte 1 (msb->lsb) : [    0,    1, bit4,    0,    1, bit3,    0,    1 ]
 # byte 2 (msb->lsb) : [    0,    0,    0,    0,    0,    0,    0,    0 ]
 # byte 3 (msb->lsb) : [ bit2,    0,    1, bit1,    0,    1, bit0,    0 ]
 #

def waveform3(bit):
	return 0b100+0b010*int(bit != 0)

bitpatterns = [ sum( waveform3( (1<<bit)&n != 0 ) << (bit*3) for bit in range(8) ) for n in range(256) ]
for i, p in enumerate(bitpatterns):
	b0 = (p>>16)&0xff
	b1 = (p>> 8)&0xff
	b2 = 0
	b3 = (p>> 0)&0xff
	print (hex(b1<<8 | b0)+','+hex(b3<<8 | b2)+',' ,end='')
	if i%8 == 7:
		print()

 */
0x4992,0x2400,0x4992,0x2600,0x4992,0x3400,0x4992,0x3600,0x4992,0xa400,0x4992,0xa600,0x4992,0xb400,0x4992,0xb600,
0x4d92,0x2400,0x4d92,0x2600,0x4d92,0x3400,0x4d92,0x3600,0x4d92,0xa400,0x4d92,0xa600,0x4d92,0xb400,0x4d92,0xb600,
0x6992,0x2400,0x6992,0x2600,0x6992,0x3400,0x6992,0x3600,0x6992,0xa400,0x6992,0xa600,0x6992,0xb400,0x6992,0xb600,
0x6d92,0x2400,0x6d92,0x2600,0x6d92,0x3400,0x6d92,0x3600,0x6d92,0xa400,0x6d92,0xa600,0x6d92,0xb400,0x6d92,0xb600,
0x4993,0x2400,0x4993,0x2600,0x4993,0x3400,0x4993,0x3600,0x4993,0xa400,0x4993,0xa600,0x4993,0xb400,0x4993,0xb600,
0x4d93,0x2400,0x4d93,0x2600,0x4d93,0x3400,0x4d93,0x3600,0x4d93,0xa400,0x4d93,0xa600,0x4d93,0xb400,0x4d93,0xb600,
0x6993,0x2400,0x6993,0x2600,0x6993,0x3400,0x6993,0x3600,0x6993,0xa400,0x6993,0xa600,0x6993,0xb400,0x6993,0xb600,
0x6d93,0x2400,0x6d93,0x2600,0x6d93,0x3400,0x6d93,0x3600,0x6d93,0xa400,0x6d93,0xa600,0x6d93,0xb400,0x6d93,0xb600,
0x499a,0x2400,0x499a,0x2600,0x499a,0x3400,0x499a,0x3600,0x499a,0xa400,0x499a,0xa600,0x499a,0xb400,0x499a,0xb600,
0x4d9a,0x2400,0x4d9a,0x2600,0x4d9a,0x3400,0x4d9a,0x3600,0x4d9a,0xa400,0x4d9a,0xa600,0x4d9a,0xb400,0x4d9a,0xb600,
0x699a,0x2400,0x699a,0x2600,0x699a,0x3400,0x699a,0x3600,0x699a,0xa400,0x699a,0xa600,0x699a,0xb400,0x699a,0xb600,
0x6d9a,0x2400,0x6d9a,0x2600,0x6d9a,0x3400,0x6d9a,0x3600,0x6d9a,0xa400,0x6d9a,0xa600,0x6d9a,0xb400,0x6d9a,0xb600,
0x499b,0x2400,0x499b,0x2600,0x499b,0x3400,0x499b,0x3600,0x499b,0xa400,0x499b,0xa600,0x499b,0xb400,0x499b,0xb600,
0x4d9b,0x2400,0x4d9b,0x2600,0x4d9b,0x3400,0x4d9b,0x3600,0x4d9b,0xa400,0x4d9b,0xa600,0x4d9b,0xb400,0x4d9b,0xb600,
0x699b,0x2400,0x699b,0x2600,0x699b,0x3400,0x699b,0x3600,0x699b,0xa400,0x699b,0xa600,0x699b,0xb400,0x699b,0xb600,
0x6d9b,0x2400,0x6d9b,0x2600,0x6d9b,0x3400,0x6d9b,0x3600,0x6d9b,0xa400,0x6d9b,0xa600,0x6d9b,0xb400,0x6d9b,0xb600,
0x49d2,0x2400,0x49d2,0x2600,0x49d2,0x3400,0x49d2,0x3600,0x49d2,0xa400,0x49d2,0xa600,0x49d2,0xb400,0x49d2,0xb600,
0x4dd2,0x2400,0x4dd2,0x2600,0x4dd2,0x3400,0x4dd2,0x3600,0x4dd2,0xa400,0x4dd2,0xa600,0x4dd2,0xb400,0x4dd2,0xb600,
0x69d2,0x2400,0x69d2,0x2600,0x69d2,0x3400,0x69d2,0x3600,0x69d2,0xa400,0x69d2,0xa600,0x69d2,0xb400,0x69d2,0xb600,
0x6dd2,0x2400,0x6dd2,0x2600,0x6dd2,0x3400,0x6dd2,0x3600,0x6dd2,0xa400,0x6dd2,0xa600,0x6dd2,0xb400,0x6dd2,0xb600,
0x49d3,0x2400,0x49d3,0x2600,0x49d3,0x3400,0x49d3,0x3600,0x49d3,0xa400,0x49d3,0xa600,0x49d3,0xb400,0x49d3,0xb600,
0x4dd3,0x2400,0x4dd3,0x2600,0x4dd3,0x3400,0x4dd3,0x3600,0x4dd3,0xa400,0x4dd3,0xa600,0x4dd3,0xb400,0x4dd3,0xb600,
0x69d3,0x2400,0x69d3,0x2600,0x69d3,0x3400,0x69d3,0x3600,0x69d3,0xa400,0x69d3,0xa600,0x69d3,0xb400,0x69d3,0xb600,
0x6dd3,0x2400,0x6dd3,0x2600,0x6dd3,0x3400,0x6dd3,0x3600,0x6dd3,0xa400,0x6dd3,0xa600,0x6dd3,0xb400,0x6dd3,0xb600,
0x49da,0x2400,0x49da,0x2600,0x49da,0x3400,0x49da,0x3600,0x49da,0xa400,0x49da,0xa600,0x49da,0xb400,0x49da,0xb600,
0x4dda,0x2400,0x4dda,0x2600,0x4dda,0x3400,0x4dda,0x3600,0x4dda,0xa400,0x4dda,0xa600,0x4dda,0xb400,0x4dda,0xb600,
0x69da,0x2400,0x69da,0x2600,0x69da,0x3400,0x69da,0x3600,0x69da,0xa400,0x69da,0xa600,0x69da,0xb400,0x69da,0xb600,
0x6dda,0x2400,0x6dda,0x2600,0x6dda,0x3400,0x6dda,0x3600,0x6dda,0xa400,0x6dda,0xa600,0x6dda,0xb400,0x6dda,0xb600,
0x49db,0x2400,0x49db,0x2600,0x49db,0x3400,0x49db,0x3600,0x49db,0xa400,0x49db,0xa600,0x49db,0xb400,0x49db,0xb600,
0x4ddb,0x2400,0x4ddb,0x2600,0x4ddb,0x3400,0x4ddb,0x3600,0x4ddb,0xa400,0x4ddb,0xa600,0x4ddb,0xb400,0x4ddb,0xb600,
0x69db,0x2400,0x69db,0x2600,0x69db,0x3400,0x69db,0x3600,0x69db,0xa400,0x69db,0xa600,0x69db,0xb400,0x69db,0xb600,
0x6ddb,0x2400,0x6ddb,0x2600,0x6ddb,0x3400,0x6ddb,0x3600,0x6ddb,0xa400,0x6ddb,0xa600,0x6ddb,0xb400,0x6ddb,0xb600,
};


rRest
rBuf
rOut
rX
rY
rZ
rCount
rP

/* // Pseudo-code
 *
 * extern uint16_t GAMMA[256], rBitmap[256*2]; // flash
 * extern uint8_t *rRest, *rBuff;
 * extern uint16_t *rOut;
 *
 * // every loop translates 2 bytes framebuffer input into 6 bytes gamma corrected waveform output
 *
 * rCount /= 2;
 * do {
 *
 * rX = *rRest++ + GAMMA[rBuff++];         // add 16 bit gamma corected value to temporal dithering remainder
 * rRest[-1] = (uint8_t)rX;                // save new remainder
 * rX = bswap16(rX);                       // byte swap value so that the low byte now contains the output color value
 *
 * rY = *rRest++ + GAMMA[rBuff++];         // same for 2nd input byte
 * rRest[-1] = (uint8_t)rY;
 * rY = bswap16(rY);
 *
 * rP = &rBitmap[ (uint8_t)rX*2 ];         // calculate lookup location
 * rOut[0] = *rP++;                        // straight copy first two of three bytes of waveform
 * rX = *rP;
 * rX = bswap16(rX);                       // low byte now contains last byte of waveform, high byte is 0
 *
 * rP = &rBitmap[ (uint8_t)rY*2 ];         // calculate lookup location
 * rY = *rP++;
 * rY = bswap16(rY);                       // load first two bytes of second waveform, swap high and low byte
 *
 * rZ = rY & 0x00ff;
 * rY = (rY & 0xff00) | rX;                // combine last byte of second waveform with fist of second
 * rOut[1] = rY;                           // 
 * rZ = rZ | *rP;                          // combine second and third bytes 
 * rOut[2] = rZ;
 *
 * rOut = &rOut[3];
 *
 * } while (--rCount);
 */


rsa rCount, rCount

loop:
2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rX
3 add GAMMA(rP), rX
3 mov.b rX, -1(rRest)
1 swapb rX
2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rY
3 add GAMMA(rP), rY
3 mov.b rY, -1(rRest)
1 swapb rY

1 mov.b rX, rP
1 add rP, rP
1 add rP, rP
1 add rBitmap, rP
4 mov   @rP+, 0(rOut)                                 out > 0xBBAA
2 mov   @rP, rX                      rX = 0xCC00
1 swap rX                            rX = 0x00CC

1 mov.b rY, rP
1 add rP, rP
1 add rP, rP
1 add rBitmap, rP
2 mov  @rP+, rY                      rY = 0xEEDD
1 swap rY                            rY = 0xDDEE
1 mov.b rY, rZ                       rZ = 0x00EE
1 xor rZ, rY                         rY = 0xDD00
1 or  rX, rY                         rY = 0xDDCC
3 mov rY, 2(rOut)                                     out > 0xDDCC
2 or  @rP, rZ                        rZ = 0xFFEE
3 mov rZ, 4(rOut)                                     out > 0xFFEE

2 add #6, rOut
1 dec rCount
2 jnz loop

58/16.

########################################  1 byte -> 4 bytes ####################################################3

unsigned uint16_t bitmap_4[] =
{
/*
 # lookup table: byte -> bit pattern (2x uint16_t, little endian)
 #
 # pattern:
 #
 # byte 0 (msb->lsb) : [    1, bit7, bit7,    0,    1, bit6, bit6,    0 ]
 # byte 1 (msb->lsb) : [    1, bit5, bit5,    0,    1, bit4, bit4,    0 ]
 # byte 2 (msb->lsb) : [    1, bit3, bit3,    0,    1, bit2, bit2,    0 ]
 # byte 3 (msb->lsb) : [    1, bit1, bit1,    0,    1, bit0, bit0,    0 ]
 #


def waveform4(bit):
	return 0b1000+0b0110*int(bit != 0)

bitpatterns = [ sum( waveform4( (1<<bit)&n != 0 ) << (bit*4) for bit in range(8) ) for n in range(256) ]
for i, p in enumerate(bitpatterns):
	b0 = (p>>24)&0xff
	b1 = (p>>16)&0xff
	b2 = (p>> 8)&0xff
	b3 = (p>> 0)&0xff
	print (hex(b1<<8 | b0)+','+hex(b3<<8 | b2)+',' ,end='')
	if i%8 == 7:
		print()

 */
0x8888,0x8888,0x8888,0x8e88,0x8888,0xe888,0x8888,0xee88,0x8888,0x888e,0x8888,0x8e8e,0x8888,0xe88e,0x8888,0xee8e,
0x8888,0x88e8,0x8888,0x8ee8,0x8888,0xe8e8,0x8888,0xeee8,0x8888,0x88ee,0x8888,0x8eee,0x8888,0xe8ee,0x8888,0xeeee,
0x8e88,0x8888,0x8e88,0x8e88,0x8e88,0xe888,0x8e88,0xee88,0x8e88,0x888e,0x8e88,0x8e8e,0x8e88,0xe88e,0x8e88,0xee8e,
0x8e88,0x88e8,0x8e88,0x8ee8,0x8e88,0xe8e8,0x8e88,0xeee8,0x8e88,0x88ee,0x8e88,0x8eee,0x8e88,0xe8ee,0x8e88,0xeeee,
0xe888,0x8888,0xe888,0x8e88,0xe888,0xe888,0xe888,0xee88,0xe888,0x888e,0xe888,0x8e8e,0xe888,0xe88e,0xe888,0xee8e,
0xe888,0x88e8,0xe888,0x8ee8,0xe888,0xe8e8,0xe888,0xeee8,0xe888,0x88ee,0xe888,0x8eee,0xe888,0xe8ee,0xe888,0xeeee,
0xee88,0x8888,0xee88,0x8e88,0xee88,0xe888,0xee88,0xee88,0xee88,0x888e,0xee88,0x8e8e,0xee88,0xe88e,0xee88,0xee8e,
0xee88,0x88e8,0xee88,0x8ee8,0xee88,0xe8e8,0xee88,0xeee8,0xee88,0x88ee,0xee88,0x8eee,0xee88,0xe8ee,0xee88,0xeeee,
0x888e,0x8888,0x888e,0x8e88,0x888e,0xe888,0x888e,0xee88,0x888e,0x888e,0x888e,0x8e8e,0x888e,0xe88e,0x888e,0xee8e,
0x888e,0x88e8,0x888e,0x8ee8,0x888e,0xe8e8,0x888e,0xeee8,0x888e,0x88ee,0x888e,0x8eee,0x888e,0xe8ee,0x888e,0xeeee,
0x8e8e,0x8888,0x8e8e,0x8e88,0x8e8e,0xe888,0x8e8e,0xee88,0x8e8e,0x888e,0x8e8e,0x8e8e,0x8e8e,0xe88e,0x8e8e,0xee8e,
0x8e8e,0x88e8,0x8e8e,0x8ee8,0x8e8e,0xe8e8,0x8e8e,0xeee8,0x8e8e,0x88ee,0x8e8e,0x8eee,0x8e8e,0xe8ee,0x8e8e,0xeeee,
0xe88e,0x8888,0xe88e,0x8e88,0xe88e,0xe888,0xe88e,0xee88,0xe88e,0x888e,0xe88e,0x8e8e,0xe88e,0xe88e,0xe88e,0xee8e,
0xe88e,0x88e8,0xe88e,0x8ee8,0xe88e,0xe8e8,0xe88e,0xeee8,0xe88e,0x88ee,0xe88e,0x8eee,0xe88e,0xe8ee,0xe88e,0xeeee,
0xee8e,0x8888,0xee8e,0x8e88,0xee8e,0xe888,0xee8e,0xee88,0xee8e,0x888e,0xee8e,0x8e8e,0xee8e,0xe88e,0xee8e,0xee8e,
0xee8e,0x88e8,0xee8e,0x8ee8,0xee8e,0xe8e8,0xee8e,0xeee8,0xee8e,0x88ee,0xee8e,0x8eee,0xee8e,0xe8ee,0xee8e,0xeeee,
0x88e8,0x8888,0x88e8,0x8e88,0x88e8,0xe888,0x88e8,0xee88,0x88e8,0x888e,0x88e8,0x8e8e,0x88e8,0xe88e,0x88e8,0xee8e,
0x88e8,0x88e8,0x88e8,0x8ee8,0x88e8,0xe8e8,0x88e8,0xeee8,0x88e8,0x88ee,0x88e8,0x8eee,0x88e8,0xe8ee,0x88e8,0xeeee,
0x8ee8,0x8888,0x8ee8,0x8e88,0x8ee8,0xe888,0x8ee8,0xee88,0x8ee8,0x888e,0x8ee8,0x8e8e,0x8ee8,0xe88e,0x8ee8,0xee8e,
0x8ee8,0x88e8,0x8ee8,0x8ee8,0x8ee8,0xe8e8,0x8ee8,0xeee8,0x8ee8,0x88ee,0x8ee8,0x8eee,0x8ee8,0xe8ee,0x8ee8,0xeeee,
0xe8e8,0x8888,0xe8e8,0x8e88,0xe8e8,0xe888,0xe8e8,0xee88,0xe8e8,0x888e,0xe8e8,0x8e8e,0xe8e8,0xe88e,0xe8e8,0xee8e,
0xe8e8,0x88e8,0xe8e8,0x8ee8,0xe8e8,0xe8e8,0xe8e8,0xeee8,0xe8e8,0x88ee,0xe8e8,0x8eee,0xe8e8,0xe8ee,0xe8e8,0xeeee,
0xeee8,0x8888,0xeee8,0x8e88,0xeee8,0xe888,0xeee8,0xee88,0xeee8,0x888e,0xeee8,0x8e8e,0xeee8,0xe88e,0xeee8,0xee8e,
0xeee8,0x88e8,0xeee8,0x8ee8,0xeee8,0xe8e8,0xeee8,0xeee8,0xeee8,0x88ee,0xeee8,0x8eee,0xeee8,0xe8ee,0xeee8,0xeeee,
0x88ee,0x8888,0x88ee,0x8e88,0x88ee,0xe888,0x88ee,0xee88,0x88ee,0x888e,0x88ee,0x8e8e,0x88ee,0xe88e,0x88ee,0xee8e,
0x88ee,0x88e8,0x88ee,0x8ee8,0x88ee,0xe8e8,0x88ee,0xeee8,0x88ee,0x88ee,0x88ee,0x8eee,0x88ee,0xe8ee,0x88ee,0xeeee,
0x8eee,0x8888,0x8eee,0x8e88,0x8eee,0xe888,0x8eee,0xee88,0x8eee,0x888e,0x8eee,0x8e8e,0x8eee,0xe88e,0x8eee,0xee8e,
0x8eee,0x88e8,0x8eee,0x8ee8,0x8eee,0xe8e8,0x8eee,0xeee8,0x8eee,0x88ee,0x8eee,0x8eee,0x8eee,0xe8ee,0x8eee,0xeeee,
0xe8ee,0x8888,0xe8ee,0x8e88,0xe8ee,0xe888,0xe8ee,0xee88,0xe8ee,0x888e,0xe8ee,0x8e8e,0xe8ee,0xe88e,0xe8ee,0xee8e,
0xe8ee,0x88e8,0xe8ee,0x8ee8,0xe8ee,0xe8e8,0xe8ee,0xeee8,0xe8ee,0x88ee,0xe8ee,0x8eee,0xe8ee,0xe8ee,0xe8ee,0xeeee,
0xeeee,0x8888,0xeeee,0x8e88,0xeeee,0xe888,0xeeee,0xee88,0xeeee,0x888e,0xeeee,0x8e8e,0xeeee,0xe88e,0xeeee,0xee8e,
0xeeee,0x88e8,0xeeee,0x8ee8,0xeeee,0xe8e8,0xeeee,0xeee8,0xeeee,0x88ee,0xeeee,0x8eee,0xeeee,0xe8ee,0xeeee,0xeeee,
};


rRest
rBuf
rOut
rX
rCount
rP

/* // Pseudo-code
 *
 * extern uint16_t GAMMA[256], rBitmap[256*2]; // flash
 * extern uint8_t *rRest, *rBuff;
 * extern uint16_t *rOut;
 *
 * // every loop translates 2 bytes framebuffer input into 6 bytes gamma corrected waveform output
 *
 * rCount /= 2;
 * do {
 *
 * rX = *rRest++ + GAMMA[rBuff++];         // add 16 bit gamma corected value to temporal dithering remainder
 * rRest[-1] = (uint8_t)rX;                // save new remainder
 * rX = bswap16(rX);                       // byte swap value so that the low byte now contains the output color value
 * rOut[0] = rBitmap[ (uint8_t)rX*2     ];
 * rOut[1] = rBitmap[ (uint8_t)rX*2 + 1 ];
 *
 * rX = *rRest++ + GAMMA[rBuff++];         // add 16 bit gamma corected value to temporal dithering remainder
 * rRest[-1] = (uint8_t)rX;                // save new remainder
 * rX = bswap16(rX);                       // byte swap value so that the low byte now contains the output color value
 * rOut[2] = rBitmap[ (uint8_t)rX*2     ];
 * rOut[3] = rBitmap[ (uint8_t)rX*2 + 1 ];
 *
 * rX = *rRest++ + GAMMA[rBuff++];         // add 16 bit gamma corected value to temporal dithering remainder
 * rRest[-1] = (uint8_t)rX;                // save new remainder
 * rX = bswap16(rX);                       // byte swap value so that the low byte now contains the output color value
 * rOut[4] = rBitmap[ (uint8_t)rX*2     ];
 * rOut[5] = rBitmap[ (uint8_t)rX*2 + 1 ];
 *
 * rOut = &rOut[6];
 *
 * } while (--rCount);
 */

loop:

2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rX
3 add GAMMA(rP), rX
3 mov.b rX, -1(rRest)
1 swapb rX
1 mov.b rX, rP
1 add rP, rP
1 add rP, rP
1 add rBitmap, rP
4 mov   @rP+, 0(rOut)
4 mov   @rP+, 2(rOut)

2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rX
3 add GAMMA(rP), rX
3 mov.b rX, -1(rRest)
1 swapb rX
1 mov.b rX, rP
1 add rP, rP
1 add rP, rP
1 add rBitmap, rP
4 mov   @rP+, 4(rOut)
4 mov   @rP+, 6(rOut)

2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rX
3 add GAMMA(rP), rX
3 mov.b rX, -1(rRest)
1 swapb rX
1 mov.b rX, rP
1 add rP, rP
1 add rP, rP
1 add rBitmap, rP
4 mov   @rP+, 8(rOut)
4 mov   @rP+,10(rOut)

2 add #12, rOut
1 dec rCount
2 jnz loop

77/24.
######################################## [ 0, 15 ] -> 4 bytes ####################################################

unsigned uint16_t bitmap_4[] =
{
/*
 # lookup table: byte -> bit pattern (uint16_t, little endian)
 #
 # pattern:
 #
 # byte 0 (msb->lsb) : [    1, bit3, bit3,    0,    1, bit2, bit2,    0 ]
 # byte 1 (msb->lsb) : [    1, bit1, bit1,    0,    1, bit0, bit0,    0 ]
 #

def waveform4(bit):
	return 0b1000+0b0110*int(bit != 0)

bitpatterns = [ sum( waveform4( (1<<bit)&n != 0 ) << (bit*4) for bit in range(8) ) for n in range(16) ]
for i, p in enumerate(bitpatterns):
	b0 = (p>> 8)&0xff
	b1 = (p>> 0)&0xff
	print (hex(b1<<8 | b0)+',' ,end='')
	if i%16 == 15:
		print()

 */
0x8888,0x8e88,0xe888,0xee88,0x888e,0x8e8e,0xe88e,0xee8e,0x88e8,0x8ee8,0xe8e8,0xeee8,0x88ee,0x8eee,0xe8ee,0xeeee,
};

rRest
rBuf
rOut
rX
rCount
rP
rBitmap

/* // Pseudo-code
 *
 * extern uint16_t GAMMA[256], rBitmap[16]; // flash
 * extern uint8_t *rRest, *rBuff;
 * extern uint16_t *rOut;
 *
 * // every loop translates 2 bytes framebuffer input into 6 bytes gamma corrected waveform output
 *
 * rCount /= 2;
 * do {
 *
 * rX = *rRest++ + GAMMA[rBuff++];         // add 16 bit gamma corected value to temporal dithering remainder
 * rRest[-1] = (uint8_t)rX;                // save new remainder
 * rX = bswap16(rX);                       // byte swap value so that the low byte now contains the output color value
 * rOut[1] = rBitmap[ (uint8_t)rX ];
 *
 * rX = *rRest++ + GAMMA[rBuff++];         // add 16 bit gamma corected value to temporal dithering remainder
 * rRest[-1] = (uint8_t)rX;                // save new remainder
 * rX = bswap16(rX);                       // byte swap value so that the low byte now contains the output color value
 * rOut[3] = rBitmap[ (uint8_t)rX ];
 *
 * rX = *rRest++ + GAMMA[rBuff++];         // add 16 bit gamma corected value to temporal dithering remainder
 * rRest[-1] = (uint8_t)rX;                // save new remainder
 * rX = bswap16(rX);                       // byte swap value so that the low byte now contains the output color value
 * rOut[5] = rBitmap[ (uint8_t)rX ];
 *
 * rOut = &rOut[6];
 *
 * } while (--rCount);
 */

loop:

2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rX
3 add GAMMA(rP), rX
3 mov.b rX, -1(rRest)
1 swapb rX
1 mov.b rX, rP
1 add rP, rP
1 add rBitmap, rP
4 mov   @rP, 2(rOut)

2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rX
3 add GAMMA(rP), rX
3 mov.b rX, -1(rRest)
1 swapb rX
1 mov.b rX, rP
1 add rP, rP
1 add rBitmap, rP
4 mov   @rP, 6(rOut)

2 mov.b @rBuf+, rP
1 add rP, rP
2 mov.b @rRest+, rX
3 add GAMMA(rP), rX
3 mov.b rX, -1(rRest)
1 swapb rX
1 mov.b rX, rP
1 add rP, rP
1 add rBitmap, rP
4 mov   @rP,10(rOut)

2 add #12, rOut
1 dec rCount
2 jnz loop

59/24.
